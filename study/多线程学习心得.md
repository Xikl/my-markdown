# java 多线程 start！
#### 1.Callable and Future 
    public class CallableAndFuture {
        public static void main(String[] args) {
            Callable<Integer> callable = new Callable<Integer>() {
                public Integer call() throws Exception {
                    return new Random().nextInt(100);
                }
            };
            FutureTask<Integer> future = new FutureTask<Integer>(callable);
            new Thread(future).start();
            try {
                Thread.sleep(5000);// 可能做一些事情
                System.out.println(future.get());
            } catch (InterruptedException e) {
                e.printStackTrace();
            } catch (ExecutionException e) {
                e.printStackTrace();
            }
        }
    }
![CSDN图标](https://openhome.cc/Gossip/DesignPattern/images/Future-1.jpg "future模式")
#### 2 future 模式示例
    public Future request(){
        final Future future = new Future();
        new Thread(){
            public void run(){
                RealSubject subject = new RealSubject();
                future.setRealSubject(subject);
            }
        }.start();  
        return future;
    }
#### 通过ExecutorService的submit来操作，自己创建一个集合来保存Future存根并循环调用其返回结果的时候，主线程并不能保证首先获得的是最先完成任务的线程返回值。它只是按加入线程池的顺序返回。因为take方法是阻塞方法，后面的任务完成了，前面的任务却没有完成，主程序就那样等待在那儿，只到前面的完成了，它才知道原来后面的也完成了
    public void testByQueue() {
        /*创建线程池*/
        ExecutorService threadPoll = Executors.newFixedThreadPool(POOL_SIZE);
        /*创建队列*/
        BlockingQueue<Future<String>> queue = new LinkedBlockingQueue<Future<String>>();
        //添加任务
        for (int i = 0; i < TOTAL_TASK; i++) {
            Future<String> future = threadPoll.submit(new MyCallable("Thead" + i));
            queue.add(future);
        }
        //检查线程池中的任务完成情况
        for (int i = 0; i < TOTAL_TASK; i++) {
            try {
                log.info("method1: " + queue.take().get());
            } catch (InterruptedException e) {
                e.printStackTrace();
            } catch (ExecutionException e) {
                e.printStackTrace();
            }
        }
        threadPoll.shutdown();
    }

#### CompletionService实现原理，使用CompletionService来维护处理线程返回结果时，主线程总是能够拿到最先完成的任务的返回值，而不管它们加入线程池的顺序。
    public void testByCompetion() {
        ExecutorService threadPool = Executors.newFixedThreadPool(POOL_SIZE);
        CompletionService<String> completionService = new ExecutorCompletionService<String>(threadPool);
        //添加任务
        for (int i = 0; i < TOTAL_TASK; i++) {
            completionService.submit(new MyCallable("Thread" + i));
        }
        // 检查线程池中任务执行结果
        for (int i = 0; i < TOTAL_TASK; i++) {
            try {
                Future<String> future = completionService.take();
                log.info("method2: " + future.get());
            } catch (InterruptedException e) {
                e.printStackTrace();
            }catch (ExecutionException e){
                e.printStackTrace();
            }
        }
        threadPool.shutdown();
    }


